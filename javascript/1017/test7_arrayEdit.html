<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>test7_배열.html</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css">
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.4/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        'use strict';
        // const arr1 = new Array();
        // console.log("arr1 : ", arr1);
        // console.log("typeof(arr1) :", typeof(arr1));
        // console.log("===============");

        const arr2 = ['사과','배', '바나나', '딸기', '포도'];
        console.log("arr2 :", arr2);
        console.log("arr2.length", arr2.length);
        console.log("===============");
        
        // 배열의 값 추가 : 뒤로 추가 push(), 앞으로 추가 unshift()
        // shift slice는 데이터를 다 뒤로 밀어넣고 앞에 집어넣는 개념(많은작업시간을요함)
        arr2.push("참외", "앵두", "자두");
        console.log(arr2);
        arr2.forEach(arr => console.log(arr));
        console.log("===============");
        arr2.unshift("키위","토마토");
        console.log(arr2);
        arr2.forEach(arr => console.log(arr));
        console.log("===============");
        
        // 배열의 값 삭제 : 뒤에서부터 삭제 pop(), 앞에서 제거: shift(), 
        arr2.pop();
        console.log(arr2);
        arr2.forEach(arr => console.log(arr));
        console.log("===============");
        arr2.shift();
        console.log(arr2);
        arr2.forEach(arr => console.log(arr));
        console.log("===============");
        
        // 지정한 요소 삭제 : splice(인덱스번호, 개수)
        // 개수가 지정되지 않았다면 인덱스 번호 이후 모두 삭제됨
        // arr2.splice(0, 2);
        // console.log(arr2);
        // arr2.forEach(arr => console.log(arr));
        // console.log("===============");
        // arr2.splice(3);
        // console.log(arr2);
        // arr2.forEach(arr => console.log(arr));
        // console.log("===============");

        // 지정한 요소 복사 : slice(시작인덱스, 종료인덱스)
        // 시작 인덱스 부터 종료인덱스 바로전 요소까지 복사됨
        let fruits = arr2.slice(3);
        console.log(typeof(fruits));
        console.log(fruits);
        fruits.forEach(arr => console.log(arr));
        console.log("===============");
        arr2.forEach(arr => console.log(arr));
        console.log("===============");
        fruits = arr2.slice(2,4);
        console.log(fruits);
        console.log("===============");

        // 문자열 합치기 : concat()
        let concatFruits = arr2.concat(fruits);
        console.log(concatFruits);
        console.log("===============");

        // 배열 안에서의 자료검색 : indexOf(요소, 시작위치), includes(), lastIndexOf() 
        console.log(concatFruits.indexOf("딸기"));
        console.log(concatFruits.indexOf("오렌지"));
        console.log(concatFruits.includes("딸기"));
        console.log(concatFruits.includes("오렌지"));
        // lastIndexOf()는 마지막 인덱스부터 찾음
        console.log(concatFruits.lastIndexOf("딸기"));
        console.log(concatFruits.lastIndexOf("오렌지"));
        console.log(concatFruits.indexOf("딸기", 4));
        console.log(concatFruits.indexOf("딸기", concatFruits.indexOf("딸기")+1));
        console.log("===============");

        console.clear();
        concatFruits.forEach( (data) => console.log(data) );
        console.log("===============");

        // map을 이용한 객체자료의 출력 : 객체명.map(([data], [index], [객체명]) => {});
        // map은 forEach와 달리 return값을 받을 수 있음
        concatFruits.map((data,idx) => console.log(data, idx));

    </script>
</head>
<body>
    <p><br /></p>
    <div class="container">
        <h2>배열(Array) 연습</h2>
    </div>
</body>
</html>